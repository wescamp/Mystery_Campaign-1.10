#textdomain wesnoth-Mystery_Campaign

#define RANDOM_NAME
    [store_unit]
        [filter]
            canrecruit=yes
        [/filter]
        variable=leaders
    [/store_unit]

    {FOREACH leaders i}
        [if]
            [variable]
                name=leaders[$i].name
                equals=$null
            [/variable]
            [then]
                [switch]
                    variable=leaders[$i].gender
                    [case]
                        value=male
                        {RANDOM (Addraecyn,Addraenvan,Addraer,Addraercyn,Addraryn,Addreddry,Addredry,Addregwyn,Addrenyc,Addreoddry,Addreoddyn,Addreonyc,Addreorcyn,Addreran,Addribryn,Addriddyn,Addrocyn,Addroryn,Addrunvan,Addrurcyn,Addryllyn,Addrynvan,Aethacyn,Aethadry,Aethaec,Aethaeran,Aethaeryn,Aethagwyn,Aethanry,Aetharcyn,Aethec,Aethellyn,Aethenvan,Aetheoc,Aetheollyn,Aetheonyc,Aetheorcyn,Aethercyn,Aetherraent,Aethibryn,Aethiddry,Aethircyn,Aethobryn,Aethoddyn,Aethonnyn,Aethuc,Aethudry,Aethugwyn,Aethun,Aethunry,Aethydry,Aethynyc,Blac,Bladoc,Blaec,Blaedry,Blanry,Blebryn,Bledoc,Blemyr,Blennyn,Blenvan,Bleollyn,Blercyn,Blidd,Bliddry,Blillyn,Blinvan,Blollyn,Blubryn,Blucyn,Bludry,Blullyn,Bluran,Blybryn,Blydd,Blygwyn,Blymyr,Blyr,Bucyn,Cac,Cadry,Caebryn,Caedry,Caeran,Caercyn,Car,Carac,Caraddry,Caradoc,Caraedry,Caraennyn,Cararyn,Caredd,Careddry,Caregwyn,Caren,Careobryn,Careogwyn,Careonvan,Careorraent,Careoryn,Carercyn,Caric,Cariddry,Carocyn,Caroddyn,Caror,Caroran,Carraent,Carudoc,Carullyn,Carygwyn,Caryn,Cebryn,Cemyr,Cennyn,Ceoc,Ceoddry,Ceoddyn,Ceomyr,Ceonnyn,Ceonry,Ceoryn,Cicyn,Cin,Cinry,Coc,Convan,Corcyn,Cubryn,Cunry,Curyn,Cynyc,Cyryn,Dac,Dadd,Dadoc,Daeddry,Daedoc,Daellyn,Demyr,Denvan,Deodd,Deollyn,Deonyc,Derraent,Dibryn,Dinnyn,Dircyn,Dycyn,Dyddyn,Gaddry,Gaebryn,Gaedry,Gaercyn,Gagwyn,Gan,Gannyn,Gar,Gecyn,Geddyn,Gegwyn,Geodry,Ginvan,Glacyn,Gladoc,Glaercyn,Glarraent,Gleddry,Gleoddyn,Gleran,Gliddyn,Glillyn,Glinry,Glircyn,Gloddry,Gloddyn,Glonry,Glonvan,Glumyr,Glun,Glunry,Glunvan,Glyc,Glydd,Glydoc,Glynry,Glynvan,Glyran,Goc,Gor,Gubryn,Gudd,Gullyn,Gumyr,Gur,Gwadoc,Gwaec,Gwaeddyn,Gwan,Gweddyn,Gwegwyn,Gwellyn,Gwennyn,Gwenyc,Gweocyn,Gweodd,Gweodoc,Gweodry,Gweogwyn,Gweoran,Gwidoc,Gwilam,Gwodd,Gwoddyn,Gwollyn,Gwor,Gwucyn,Gwudoc,Gwumyr,Gwuran,Gwybryn,Gwycyn,Gwyddry,Gwydoc,Gwymyr,Gwynnyn,Gydoc,Gyllyn,Gymyr,Haldar,Labryn,Ladoc,Laellyn,Lan,Lannyn,Laran,Lec,Lemyr,Lenvan,Leogwyn,Lercyn,Ligwyn,Lin,Liryn,Lonnyn,Lorraent,Luddry,Ludoc,Lunnyn,Lunvan,Lurraent,Mac,Maddyn,Maennyn,Manry,Manyc,Marcyn,Mec,Menvan,Meollyn,Meon,Meonnyn,Meorraent,Middry,Midry,Mimyr,Modd,Moddry,Monry,Moran,Morcyn,Mubryn,Mudoc,Mugwyn,Murcyn,Mydoc,Mygwyn,Myn,Myrraent,Owac,Owadd,Owaddyn,Owaecyn,Owaedry,Owain,Owarcyn,Owaryn,Owecyn,Owedry,Oweomyr,Oweor,Oweorcyn,Oweran,Owercyn,Owidry,Owinvan,Owinyc,Owodd,Owoddry,Owogwyn,Owollyn,Oworan,Oworcyn,Oworraent,Owuddry,Owuddyn,Owugwyn,Owur,Owyran,Rabryn,Radd,Ranvan,Rar,Reoddyn,Reodry,Rhaecyn,Rhaedoc,Rhaemyr,Rhaerraent,Rhanry,Rharcyn,Rhenry,Rhenvan,Rhenyc,Rheodd,Rheoddyn,Rheollyn,Rheor,Rheoran,Rheorraent,Rheran,Rherraent,Rhobryn,Rhodry,Rhollyn,Rhonvan,Rhubryn,Rhugwyn,Rhunyc,Rhur,Rhygwyn,Rhyllyn,Rhynyc,Rhyrcyn,Rhyrraent,Rocyn,Roddyn,Romyr,Ron,Ronry,Rubryn,Ruddry,Rumyr,Run,Rurcyn,Rybryn,Rycyn,Ryddry,Rygwyn,Rynnyn,Rynry,Saec,Saellyn,Saemyr,Saenvan,Saercyn,Sanyc,Saran,Sarraent,Secyn,Seddyn,Sedry,Sellyn,Sennyn,Seoddry,Seorcyn,Sercyn,Siddry,Simyr,Siryn,Sodd,Sodry,Soran,Suc,Sudd,Surcyn,Sydd,Syran,Syryn,Tabryn,Taec,Taedd,Taedoc,Taemyr,Taenvan,Taercyn,Tanry,Tarcyn,Teddyn,Tegwyn,Ten,Tennyn,Tenvan,Teobryn,Teoddyn,Teor,Teorcyn,Terraent,Tinry,Tinvan,Tiryn,Todd,Tudd,Tuddry,Tudoc,Tunvan,Turraent,Tyddyn,Vaddyn,Vaeddyn,Vaedry,Vaennyn,Varcyn,Ven,Vennyn,Veocyn,Veoddyn,Veodry,Veogwyn,Veomyr,Vinvan,Vinyc,Virraent,Vobryn,Vogwyn,Vonry,Vuddyn,Vugwyn,Vyc,Vygwyn,Vyrcyn,Yracyn,Yraec,Yran,Yrannyn,Yranvan,Yraryn,Yredd,Yreddyn,Yregwyn,Yreryn,Yrinvan,Yrirraent,Yroddry,Yrullyn,Yrumyr,Yrunnyn,Yrunvan,Yryllyn,Yrymyr,Yrynyc,Yryrcyn)}
                    [/case]
                    [case]
                        value=female
                        {RANDOM (Alabrylla,Alaebrylla,Alaeniver,Alalla,Alalonna,Alaryan,Aleacla,Aleaniver,Aleara ,Alearka,Alena,Alengwen,Alilonna,Alingwen,Alolla,Alolonna,Alora,Alubrylla, Aluniver,Aluryan,Alussa,Alwcla,Alwllyra,Alwlyan,Alwna,Alybrylla,Alynoic,Alyra, Alyryan,Braedda,Brassa,Bravyan,Breabrylla,Breall,Brealla,Brealonna,Breana,Brell, Brellyra,Brera,Brerka,Breryan,Bricla,Brirka,Brobrylla,Brollyra,Brona,Bronoic, Brora,Brorka,Brungwen,Bruryan,Brwra,Brycla,Brynoic,Caella,Caena,Caengwen,Caevyan ,Call,Calla,Cassa,Cealonna,Cera,Ceryan,Cibrylla,Cicla,Cinoic,Cira,Cissa,Clacla, Claella,Claelyan,Claenoic,Clalla,Clallyra,Clara,Clarka,Clavyan,Cleacla,Cleall, Clealyan,Cleana,Cleanoic,Clenoic,Clibrylla,Clill,Clillyra,Clilyan,Clinoic,Clissa ,Clobrylla,Clollyra,Clona,Clongwen,Clungwen,Clurka,Cluvyan,Clwdda,Clwlla,Clwvyan ,Clydda,Clylla,Cora,Coryan,Cucla,Cudda,Curyan,Cwdda,Cwlonna,Cwngwen,Cwvyan,Cydda ,Cylla,Cyllyra,Cylyan,Cyniver,Cyvyan,Daedda,Daelyan,Daengwen,Daenoic,Dalla, Dallyra,Dangwen,Dara,Dassa,Deanoic,Deassa,Della,Devyan,Dicla,Diniver,Dissa, Dollyra,Dullyra,Dulonna,Dwbrylla,Dwdda,Dwna,Dwnoic,Dwra,Dybrylla,Dydda,Dyssa, Elacla,Elaedda,Elaell,Elaelonna,Elaessa,Elaevyan,Elallyra,Elalonna,Elara,Elavyan ,Elealla,Eleanoic,Elearka,Elenoic,Elerka,Elivyan,Elulonna,Elurka,Elwllyra, Elwlonna,Elwngwen,Elwra,Elycla,Elyllyra,Elyngwen,Elyniver,Elyrka,Gwaera,Gwaessa, Gwangwen,Gweacla,Gwedda,Gwerka,Gwicla,Gwirka,Gwobrylla,Gwoll,Gwona,Gwongwen, Gwonoic,Gworyan,Gwullyra,Gwussa,Gwwcla,Gwwna,Gwwvyan,Gwycla,Gwydda,Heldra,Jacla, Jaena,Jaerka,Jaevyan,Jalyan,Jana,Jarka,Jassa,Jeabrylla,Jealla,Jeanoic,Jeniver, Jiryan,Jissa,Joll,Jolla,Jona,Jongwen,Jonoic,Jora,Jorka,Jovyan,Judda,Jull,Julonna ,Jura,Jwll,Jwlyan,Jycla,Jyniver,Jynoic,Jyrka,Jyvyan,Laeniver,Laenoic,Laeryan, Langwen,Larka,Lassa,Lealonna,Lealyan,Ledda,Lelonna,Lelyan,Lengwen,Lerka,Lessa, Lidda,Lill,Lina,Lirka,Liryan,Livyan,Locla,Lodda,Lollyra,Lolonna,Lulla,Lulyan, Lungwen,Lunoic,Luryan,Lwcla,Lwlla,Lwnoic,Lwryan,Lycla,Lylla,Lylyan,Lyna,Lynoic, Maecla,Maeniver,Mavyan,Meacla,Mealyan,Meana,Meangwen,Meanoic,Medda,Melonna, Mengwen,Meniver,Meradda,Meraecla,Meraelyan,Merall,Merallyra,Meralonna,Merana, Meranoic,Merealonna,Mereangwen,Mereaniver,Merebrylla,Merella,Merengwen,Meressa, Merilyan,Merina,Merinoic,Merissa,Merivyan,Merolla,Merolyan,Merona,Meroniver, Merubrylla,Merudda,Merurka,Merwlla,Merwnoic,Merwryan,Merydda,Merylyan,Messa, Milonna,Molyan,Moniver,Mossa,Mudda,Mullyra,Mulyan,Muryan,Mwbrylla,Mwlyan,Mwngwen ,Mwnoic,Mycla,Myll,Mylla,Myra,Myvyan,Nabrylla,Naebrylla,Naecla,Naell,Nalyan, Nangwen,Nealla,Neallyra,Nealonna,Neavyan,Nera,Nessa,Ninoic,Niryan,Nivyan, Nobrylla,Nolla,Nonoic,Norka,Noryan,Nucla,Nulla,Nulyan,Nungwen,Nuvyan,Nwllyra, Nwryan,Nwvyan,Nybrylla,Nyll,Nylyan,Nyryan,Nyssa,Nyvyan,Raebrylla,Raera,Raerka, Ralonna,Rara,Rarka,Rassa,Reacla,Realla,Reana,Reangwen,Rella,Relyan,Rengwen,Rerka ,Revyan,Rilonna,Rilyan,Rirka,Rora,Rucla,Ruryan,Rwdda,Rwlla,Rwllyra,Rwlonna, Rwngwen,Rybrylla,Ryna,Ryngwen,Saell,Saellyra,Saeniver,Saerka,Saessa,Sallyra, Sanoic,Sara,Sassa,Searka,Sena,Senoic,Sera,Silonna,Sira,Siryan,Sona,Sorka, Subrylla,Sull,Sulonna,Sulyan,Sura,Sussa,Swlla,Swlyan,Swngwen,Swnoic,Swvyan, Syllyra,Sylyan,Syssa,Ysacla,Ysaenoic,Ysaerka,Ysanoic,Yseacla,Ysealonna,Ysealyan, Ysedda,Ysell,Yselonna,Ysilyan,Ysinoic,Ysodda,Ysongwen,Ysonoic,Ysura,Yswniver, Ysycla,Ysylla,Ysylyan,Ysyrka,Ysyssa)}
                    [/case]
                [/switch]

                {VARIABLE leaders[$i].name $random}
                [unstore_unit]
                    variable=leaders[$i]
                    find_vacant=no
                [/unstore_unit]
                {CLEAR_VARIABLE random}
            [/then]
        [/if]
    {NEXT i}
    {CLEAR_VARIABLE leaders}
#enddef

#define	ALLY
    [switch]
        variable=global.funding_mode
        [case]
            value="Moderate"
            [set_variable]
                name=chance
                {QUANTITY value 20 10 5}
            [/set_variable]
        [/case]
        [case]
            value="Excessive"
            [set_variable]
                name=chance
                {QUANTITY value 10 5 0}
            [/set_variable]
        [/case]
        [else]
            [set_variable]
                name=chance
                {QUANTITY value 0 10 10}
            [/set_variable]
        [/else]
    [/switch]

    [if]
        [variable]
            name=scenario_number
            greater_than=3
        [/variable]
        [and]
            [variable]
                name=side_3.ally
                equals=no
            [/variable]
        [/and]
        [then]
            {RANDOM (0..99)}
            {IF_VAR random less_than $chance (
                [then]
                    {VARIABLE side_3.ally yes}

                    {VARIABLE sides 1}
                    [while]
                        [variable]
                            name=sides
                            less_than=3
                        [/variable]
                        [do]
                            [store_starting_location]
                                side=$sides
                                variable=loc$sides
                            [/store_starting_location]
                            {VARIABLE_OP sides add 1}
                        [/do]
                    [/while]
                    {CLEAR_VARIABLE sides}

                    [store_map_dimensions]
                        variable=map
                    [/store_map_dimensions]
                    #{DEBUG_MSG (map width is $map.width and heigth is $map.heigth)}

                    [store_locations]
                        variable=possible_locs
                        x,y="2-$($map.width-1),2-($map.heigth-1)"
                        [not]
                            x,y=$loc1.x,$loc1.y
                            radius=8
                        [/not]
                        [not]
                            x,y=$loc2.x,$loc2.y
                            radius=16
                        [/not]
                        [not]
                            terrain=Qx*,W*,Q*,X*,Xu,Xuc
                        [/not]
                    [/store_locations]

                    #{DEBUG_MSG (number of possible locs $possible_locs.length)}
                    {VARIABLE_OP where rand(0.."$($possible_locs.length-1)")}
                    #{DEBUG_MSG (keep loc is at $possible_locs[$where].x,$possible_locs[$where].y)}
                    [terrain]
                        x,y=$possible_locs[$where].x,$possible_locs[$where].y
                        terrain=Kh
                    [/terrain]
                    [store_locations]
                        variable=castle
                        [filter_adjacent_location]
                            x,y=$possible_locs[$where].x,$possible_locs[$where].y
                        [/filter_adjacent_location]
                    [/store_locations]
                    {FOREACH castle i}
                        [terrain]
                            x,y=$castle[$i].x,$castle[$i].y
                            terrain=Ch
                        [/terrain]
                    {NEXT i}

                    [unstore_unit]
                        variable=side_3.leader[0]
                        x,y=$possible_locs[$where].x,$possible_locs[$where].y
                    [/unstore_unit]

                    {VARIABLE side_3.previous_previous_faction $side_3.previous_faction}
                    {VARIABLE side_3.previous_faction $side_3.faction}

                    {CLEAR_VARIABLE loc1,loc2,possible_locs,where,castle,map}
                [/then]
            )}
            {CLEAR_VARIABLE random}
        [/then]
        [else]
            {VARIABLE side_3.ally no}
        [/else]
    [/if]
    {CLEAR_VARIABLE chance}

    [if]
        [variable]
            name=side_3.ally
            equals=no
        [/variable]
        [then]
            [modify_side]
                side=3
                hidden=yes
                controller=null
            [/modify_side]
        [/then]
    [/if]
#enddef

#define RANDOM_NONPLAYER_FACTION SIDE
    {VARIABLE_OP side_{SIDE}.faction rand($global.factions)}
    [while]
        [variable]
            name=side_{SIDE}.faction
            equals=$side_1.faction
        [/variable]
        [or]
            [variable]
                name=side_{SIDE}.faction
                equals=$side_{SIDE}.previous_previous_faction
            [/variable]
        [/or]
        [or]
            [variable]
                name=side_{SIDE}.faction
                equals=$side_{SIDE}.previous_faction
            [/variable]
        [/or]
        [or]
            [variable]
                name=side_3.faction
                equals=$side_2.faction
            [/variable]
        [/or]
        [do]
            {VARIABLE_OP side_{SIDE}.faction rand($global.factions)}
        [/do]
    [/while]

    {VARIABLE side {SIDE}}
    {IF_VAR side equals 2 (
        [then]
            {VARIABLE side_{SIDE}.previous_previous_faction $side_{SIDE}.previous_faction}
            {VARIABLE side_{SIDE}.previous_faction $side_{SIDE}.faction}
        [/then]
    )}
    {CLEAR_VARIABLE side}
#enddef

#define ENSURE_GOLD SIDE AMOUNT
    [gold]
        side={SIDE}
        amount={AMOUNT}
    [/gold]
    [store_gold]
        side={SIDE}
    [/store_gold]
    {IF_VAR gold less_than {AMOUNT} (
        [then]
            [modify_side]
                side={SIDE}
                gold={AMOUNT}
            [/modify_side]
        [/then]
    )}
    {CLEAR_VARIABLE gold}
#enddef

#define SURRENDER SIDE
    [event]
        name=prestart
        {VARIABLE_OP side_{SIDE}.ratio rand(2..4)}
    [/event]

    [event]
        name=side {SIDE} turn refresh
        first_time_only=no

        [filter_condition]
            [variable]
                name=turn_number
                greater_than_equal_to=3
            [/variable]
        [/filter_condition]

        [store_unit]
            [filter]
                side=$side_number
                {EVERYWHERE}
            [/filter]
            variable=my_units
        [/store_unit]

        [switch]
            variable=side_number
            [case]
                value=2
                [store_unit]
                    [filter]
                        [not]
                            side=$side_number
                        [/not]
                        {EVERYWHERE}
                    [/filter]
                    variable=enemy_units
                [/store_unit]
            [/case]
            [case]
                value=3
                [store_unit]
                    [filter]
                        [not]
                            side=$side_number
                        [/not]
                        [not]
                            side=1
                        [/not]
                        {EVERYWHERE}
                    [/filter]
                    variable=enemy_units
                [/store_unit]
            [/case]
        [/switch]

        [while]
            {VARIABLE_CONDITIONAL i less_than $my_units.length}
            [do]
                [unit_worth]
                    id="$my_units[$i].id"
                [/unit_worth]
                {VARIABLE_OP side_$side_number|_worth add $unit_worth}
                {VARIABLE_OP i add 1}
            [/do]
        [/while]
        {CLEAR_VARIABLE (my_units,i)}

        [while]
            {VARIABLE_CONDITIONAL i less_than $enemy_units.length}
            [do]
                [unit_worth]
                    id="$enemy_units[$i].id"
                [/unit_worth]
                {VARIABLE_OP enemy_of_$side_number|_worth add $unit_worth}
                {VARIABLE_OP i add 1}
            [/do]
        [/while]
        {CLEAR_VARIABLE (enemy_units,i)}

        #{DEBUG_MSG ("side 1 worth: $enemy_of_$side_number|_worth")}
        #{DEBUG_MSG ("side 2 worth: $side_$side_number|_worth")}

        [store_gold]
            side={SIDE}
        [/store_gold]
        #[inspect][/inspect]

        [if]
            [variable]
                name=gold
                less_than=$cheapest_unit_side_{SIDE}
            [/variable]
            [and]
                [variable]
                    name=side_{SIDE}.ratio
                    less_than="$($enemy_of_$side_number|_worth/$side_$side_number|_worth)"
                [/variable]
            [/and]
            [then]
                [message]
                    side={SIDE}
                    canrecruit=yes
                    message= _ "Oh, it's hopeless! I surrender!"
                [/message]
                [kill]
                    side={SIDE}
                    canrecruit=yes
                    animate=no
                    fire_event=yes
                [/kill]
            [/then]
        [/if]
        {CLEAR_VARIABLE (gold,enemy_of_$side_number|_worth,side_$side_number|_worth,unit_worth,experience,cost,next_cost,health)}
        #[inspect][/inspect]
    [/event]
    [event]
        name=victory,defeat
        {CLEAR_VARIABLE (my_units,enemy_units,gold)}
        {CLEAR_VARIABLE (enemy_of_$side_number|_worth,side_{SIDE}_worth,unit_worth,experience,cost,next_cost,health)}
    [/event]
#enddef

#define NEXT_SCENARIO
    {VARIABLE_OP next rand(spring,cave,fall,summer,isles,winter,desert,swamp)}
    [while]
        [variable]
            name=next
            equals=$global.previous_scenario
        [/variable]
        [or]
            [variable]
                name=next
                equals=$global.previous_previous_scenario
            [/variable]
        [/or]
        [do]
            {VARIABLE_OP next rand(spring,cave,fall,summer,isles,winter,desert,swamp)}
        [/do]
    [/while]
    [endlevel]
        result=victory
        next_scenario=mystery_scenario_$next|
        bonus=no
        carryover_report=yes
        save=no
        replay_save=no
        {NEW_GOLD_CARRYOVER 40}
    [/endlevel]
    {VARIABLE global.previous_previous_scenario $global.previous_scenario}
    {VARIABLE global.previous_scenario $next}
    {CLEAR_VARIABLE next}
#enddef

#define CONVERT_TO_GREAT_TREE TERRAIN
    [event]
        name=prestart

        [store_locations]
            terrain=*^F*
            [filter_adjacent_location]
                terrain=*^F*
                count=6
            [/filter_adjacent_location]
            variable=to_convert
        [/store_locations]

        {FOREACH to_convert i}
            [terrain]
                terrain={TERRAIN}
                x,y=$to_convert[$i].x,$to_convert[$i].y
                [not]
                    [filter_adjacent_location]
                        terrain={TERRAIN}
                        count=1-6
                    [/filter_adjacent_location]
                [/not]
            [/terrain]
        {NEXT i}
        {CLEAR_VARIABLE to_convert}
    [/event]
#enddef

#define SCATTER_CASTLES
    [event]
        name=prestart

        [store_map_dimensions]
            variable=map
        [/store_map_dimensions]

        {VARIABLE_OP random_number_of_castles rand(2..6)}

        {REPEAT $random_number_of_castles (
            [store_locations]
                #{EVERYWHERE}
                x,y="2-$($map.width-1),2-$($map.heigth-1)"
                [not]
                    terrain="K*"
                    radius=9
                [/not]
                [not]
                    terrain=Wo*,Xu*
                [/not]
                variable=possible_locs
            [/store_locations]

            {VARIABLE_OP random_loc rand(1..$possible_locs.length)}
            {VARIABLE_OP random_loc sub 1}
            {LOOKUP_INDEX castle_loc x $possible_locs[$random_loc].x index}
            #[inspect][/inspect]
            [while]
                {VARIABLE_CONDITIONAL possible_locs[$random_loc].x equals $castle_loc[$index].x}
                [and]
                    {VARIABLE_CONDITIONAL possible_locs.length greater_than 0}
                [/and]
                [do]
                    {VARIABLE_OP random_loc rand(1..$possible_locs.length)}
                    {VARIABLE_OP random_loc sub 1}
                    {CLEAR_VARIABLE index}
                    {LOOKUP_INDEX castle_loc x $possible_locs[$random_loc].x index}
                [/do]
            [/while]

            {VARIABLE castle_loc[$REPEAT_i].x $possible_locs[$random_loc].x}
            {VARIABLE castle_loc[$REPEAT_i].y $possible_locs[$random_loc].y}
            [terrain]
                terrain=Kh
                x,y=$possible_locs[$random_loc].x,$possible_locs[$random_loc].y
            [/terrain]

            [store_locations]
                [filter_adjacent_location]
                    x,y=$possible_locs[$random_loc].x,$possible_locs[$random_loc].y
                [/filter_adjacent_location]
                variable=for_castle
            [/store_locations]

            {VARIABLE_OP how_many rand(1..3)}
            [while]
                [variable]
                    name=REPEAT_j
                    less_than=$how_many
                [/variable]
                [variable]
                    name=converted
                    less_than=$for_castle.length
                [/variable]
                [do]
                    {VARIABLE_OP random_castles rand(1..$for_castle.length)}
                    {VARIABLE_OP random_castles sub 1}

                    {IF_VAR for_castle[$random_castles].terrain contains ("V") (
                        [else]
                            [terrain]
                                terrain=Ch
                                x,y=$for_castle[$random_castles].x,$for_castle[$random_castles].y
                            [/terrain]
                            {VARIABLE_OP converted add 1}
                        [/else]
                    )}
                    {VARIABLE_OP REPEAT_j add 1}
                [/do]
            [/while]
            {CLEAR_VARIABLE (random_castles,random_loc,for_castle,index,random,possible_locs,REPEAT_j,how_many,converted)}
        )}
        {CLEAR_VARIABLE (castle_loc,player,enemy,random_number_of_castles,map)}
    [/event]
#enddef

#define CONVERT_CASTLE A
    [event]
        name=prestart

        [store_locations]
            terrain=Kh
            variable=keeps
        [/store_locations]

        {FOREACH keeps i}
            [store_locations]
                terrain=Ch
                [and]
                    x,y=$keeps[$i].x,$keeps[$i].y
                    radius={INFINITY}
                    [filter_radius]
                        terrain=Ch
                    [/filter_radius]
                [/and]
                variable=castle
            [/store_locations]

            {VARIABLE_OP type rand({A})}
            [terrain]
                x,y=$keeps[$i].x,$keeps[$i].y
                terrain=K$type
            [/terrain]

            {FOREACH castle j}
                [terrain]
                    x,y=$castle[$j].x,$castle[$j].y
                    terrain=C$type
                [/terrain]
            {NEXT j}

            {CLEAR_VARIABLE castle,type}
        {NEXT i}
        {CLEAR_VARIABLE keeps}
    [/event]
#enddef

#define RECALL_LEADER SIDE
    {IF_VAR scenario_number not_equals 1 (
        [then]
            [store_starting_location]
                side={SIDE}
            [/store_starting_location]

            [recall]
                side={SIDE}
                canrecruit=yes
                x,y=$location.x,$location.y
            [/recall]
            {CLEAR_VARIABLE location}
        [/then]
    )}
#enddef

#define PERSISTENT_SIDE SIDE
    [event]
        name=victory

        [store_unit]
            [filter]
                side={SIDE}
                canrecruit=yes
            [/filter]
            variable=side_{SIDE}.leader
        [/store_unit]

        [store_unit]
            [filter]
                side={SIDE}
                canrecruit=no
            [/filter]
            variable=side_{SIDE}.units
        [/store_unit]

        [store_side]
            [filter]
                side={SIDE}
            [/filter]
            variable=side_{SIDE}.stats
        [/store_side]
    [/event]

    [event]
        name=prestart

        [filter_condition]
            [variable]
                name=scenario_number
                not_equals=1
            [/variable]
        [/filter_condition]

        [store_starting_location]
            side={SIDE}
        [/store_starting_location]

        [heal_unit]
            [filter]
                id=$side_{SIDE}.leader.id
            [/filter]
            amount=999
        [/heal_unit]

        [unstore_unit]
            variable=side_{SIDE}.leader
            x,y=$location.x,$location.y
        [/unstore_unit]

        {FOREACH side_{SIDE}.units index}
            [heal_unit]
                [filter]
                    id=$side_{SIDE}.units[$index].id
                [/filter]
                amount=999
            [/heal_unit]

            [unstore_unit]
                variable=side_{SIDE}.units[$index]
                x,y=recall,recall
            [/unstore_unit]
        {NEXT index}

        [modify_side]
            side={SIDE}
            recruit=$side_{SIDE}.stats.recruit
            gold=$side_{SIDE}.gold
        [/modify_side]
        {CLEAR_VARIABLE location}
    [/event]
#enddef

#define MP_SCENARIO ID GREAT_TREE CASTLE_TYPE
    [generator]
        {MAP_GENERATOR_{ID}}
    [/generator]
    {CONVERT_TO_GREAT_TREE {GREAT_TREE}}
    {SCATTER_CASTLES}
    {CONVERT_CASTLE {CASTLE_TYPE}}
#enddef

#define HEIGHT ALTITUDE TERRAIN
    [height]
        height={ALTITUDE}
        terrain={TERRAIN}
    [/height]
#enddef

#define MC_ROAD_COST TERRAIN COST NEW_TERRAIN
    [road_cost]
        terrain={TERRAIN}
        cost={COST}
        convert_to={NEW_TERRAIN}
    [/road_cost]
#enddef

#define MC_ROAD_COST_BRIDGE TERRAIN COST BRIDGE ALT
    [road_cost]
        terrain={TERRAIN}
        cost={COST}
        convert_to_bridge={BRIDGE}
        convert_to={ALT}
    [/road_cost]
#enddef

#define VILLAGE TERRAIN TYPE RATING LIKED_TERRAINLIST
    # Syntax shortcut
    [village]
        terrain={TERRAIN}
        convert_to={TYPE}
        rating={RATING}
        adjacent_liked={LIKED_TERRAINLIST}
    [/village]
#enddef

#define CONVERT MINHEIGHT MAXHEIGHT MINTEMP MAXTEMP TERRAINLIST NEW_TERRAIN
    # Convert terrains to a terrain within the specified height and temp ranges.
    [convert]
        min_height={MINHEIGHT}
        max_height={MAXHEIGHT}
        min_temperature={MINTEMP}
        max_temperature={MAXTEMP}
        from={TERRAINLIST}
        to={NEW_TERRAIN}
    [/convert]
#enddef

#define MIN_COST_ROAD X
    [road_cost]
        terrain={X}
        cost=1
        convert_to={X}
    [/road_cost]
#enddef

#define VICTORY_AND_DEFEAT_MUSIC
    [event]
        name=victory
        [music]
            name=silence.ogg
            append=no
            ms_before=0
        [/music]
        [music]
            name=victory2.ogg
            play_once=yes
            immediate=yes
        [/music]
    [/event]
    [event]
        name=defeat
        [music]
            name=silence.ogg
            append=no
            ms_before=0
        [/music]
        [music]
            name=defeat.ogg
            play_once=yes
            immediate=yes
        [/music]
    [/event]
#enddef

#ramdomly recruits some units of a particular side
#define RANDOM_RECRUITS SIDE
    [event]
        name=side {SIDE} turn

        #store side recruit
        [store_side]
            side={SIDE}
            variable=stored_side_{SIDE}
        [/store_side]

        #split them into an array
        [set_variables]
            name=recruit_of_side_{SIDE}
            [split]
                list=$stored_side_{SIDE}.recruit
                separator=,
                key=type
            [/split]
        [/set_variables]

        #temporaly disallow recruit all units
        [set_recruit]
            side={SIDE}
            recruit=""
        [/set_recruit]

        # get a random recruit for the first time
        {VARIABLE_OP random_recruit_of_{SIDE} rand(1..$recruit_of_side_{SIDE}.length)}
        {VARIABLE_OP random_recruit_of_{SIDE} sub 1}

        # allow recruiting that unit
        [allow_recruit]
            side={SIDE}
            type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
        [/allow_recruit]
        #[inspect][/inspect]

        # store the unit recruited
        [set_variables]
            name=already_recruited_of_{SIDE}
            [value]
                type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
            [/value]
        [/set_variables]

        # need to know the cheapest_unit to recruit
        {FOREACH recruit_of_side_{SIDE} i}
            [unit]
                side={SIDE}
                type=$recruit_of_side_{SIDE}[$i].type
                to_variable=dummy.$i
            [/unit]
        {NEXT i}

        {VARIABLE best_index 0}
        {FOREACH recruit_of_side_{SIDE} i}
            {IF_VAR dummy.$i|.cost less_than $dummy.$best_index|.cost (
                [then]
                    {VARIABLE best_index $i}
                [/then]
            )}
            {VARIABLE recruit_of_side_{SIDE}[$i].cost $dummy.$i|.cost}
        {NEXT i}

        {VARIABLE cheapest_unit_side_{SIDE} $dummy.$best_index|.cost}
        {CLEAR_VARIABLE (best_index,dummy)}

        # everytime the sides recruits disallow the previous recruit and generate a new one
        [event]
            name=recruit
            first_time_only=no

            [filter]
                side={SIDE}
            [/filter]

            [disallow_recruit]
                side={SIDE}
                type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
            [/disallow_recruit]

            [store_gold]
                side={SIDE}
            [/store_gold]

            # if all units are already recruited all types are allowed again except the last recruited
            {IF_VAR already_recruited_of_{SIDE}.length equals $recruit_of_side_{SIDE}.length (
                [then]
                    [set_variables]
                        name=already_recruited_of_{SIDE}
                        mode=replace
                        [value]
                            type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
                        [/value]
                    [/set_variables]
                [/then]
            )}

            {VARIABLE_OP random_recruit_of_{SIDE} rand(1..$recruit_of_side_{SIDE}.length)}
            {VARIABLE_OP random_recruit_of_{SIDE} sub 1}
            {LOOKUP_INDEX already_recruited_of_{SIDE} type $recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type index_of_recruit}
            #[inspect][/inspect]
            [while]
                [variable]
                    name=index_of_recruit
                    not_equals=$already_recruited_of_{SIDE}.length
                [/variable]
                [and]
                    [variable]
                        name=recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
                        equals=$already_recruited_of_{SIDE}[$index_of_recruit].type
                    [/variable]
                [/and]
                [or]
                    [and]
                        [variable]
                            name=recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].cost
                            greater_than=$gold
                        [/variable]
                        [variable]
                            name=gold
                            greater_than_equal_to=$cheapest_unit_side_{SIDE}
                        [/variable]
                    [/and]
                [/or]
                [do]
                    #repeat if previously recruited
                    {VARIABLE_OP random_recruit_of_{SIDE} rand(1..$recruit_of_side_{SIDE}.length)}
                    {VARIABLE_OP random_recruit_of_{SIDE} sub 1}
                    {CLEAR_VARIABLE index_of_recruit}
                    {LOOKUP_INDEX already_recruited_of_{SIDE} type $recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type index_of_recruit}
                [/do]
            [/while]

            [allow_recruit]
                side={SIDE}
                type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
            [/allow_recruit]

            # store the units already_recruited
            [set_variables]
                name=already_recruited_of_{SIDE}
                mode=append
                [value]
                    type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
                [/value]
            [/set_variables]
            {CLEAR_VARIABLE (index_of_recruit,gold)}
        [/event]
    [/event]

    [event]
        name=victory,defeat,time over,enemies defeated
        {CLEAR_VARIABLE (recruit_of_side_{SIDE},already_recruited_of_{SIDE},stored_side_{SIDE},cheapest_unit_side_{SIDE},random_recruit_of_{SIDE})}
    [/event]
#enddef

#define GIVE_GENERIC_PORTRAIT SIDE
    [if]
        [variable]
            name=leader{SIDE}.race
            contains=human
        [/variable]
        #[or]
        #	[variable]
        #		name=leader{SIDE}.race
        #		contains=khalifate
        #	[/variable]
        #[/or]
        [or]
            [variable]
                name=leader{SIDE}.race
                contains=aragwaith
            [/variable]
        [/or]
        [then]
            [switch]
                variable=leader{SIDE}.gender
                [case]
                    value=female
                    [switch]
                        variable=leader{SIDE}.alignment
                        [case]
                            value=lawful
                            {VARIABLE profile{SIDE} ("portraits/human_female.png")}
                        [/case]
                        [case]
                            value=chaotic
                            {VARIABLE profile{SIDE} ("portraits/lady_outlaw.png")}
                        [/case]
                        [else]
                            {VARIABLE profile{SIDE} ("portraits/human_neutral.png")}
                        [/else]
                    [/switch]
                [/case]
                [else]
                    [switch]
                        variable=leader{SIDE}.alignment
                        [case]
                            value=lawful
                            {VARIABLE profile{SIDE} ("portraits/humans/transparent/swordsman-3.png")}
                        [/case]
                        [case]
                            value=chaotic
                            {VARIABLE profile{SIDE} ("portraits/humans/transparent/thug.png")}
                        [/case]
                        [else]
                            {VARIABLE profile{SIDE} ("portraits/human_male.png")}
                        [/else]
                    [/switch]
                [/else]
            [/switch]
        [/then]
    [/if]

    [if]
        [variable]
            name=leader{SIDE}.race
            contains=elf
        [/variable]
        [then]
            [switch]
                variable=leader{SIDE}.gender
                [case]
                    value=female
                    {VARIABLE profile{SIDE} ("portraits/elf_female.png")}
                [/case]
                [else]
                    {VARIABLE profile{SIDE} ("portraits/elf_male.png")}
                [/else]
            [/switch]
        [/then]
    [/if]

    [if]
        [variable]
            name=leader{SIDE}.race
            contains=dwarf
        [/variable]
        [then]
            {VARIABLE profile{SIDE} ("portraits/dwarf.png")}
        [/then]
    [/if]

    [if]
        [variable]
            name=leader{SIDE}.race
            contains=undead
        [/variable]
        [then]
            {VARIABLE profile{SIDE} ("portraits/undead/transparent/archer.png")}
        [/then]
    [/if]

    [if]
        [variable]
            name=leader{SIDE}.profile
            contains="units/" # in 99.9% of cases the base image
        [/variable]
        [then]
            [if]
                [variable]
                    name=profile{SIDE}
                    equals=$empty
                [/variable]
                [then]
                    {RANDOM 2..6}
                    {VARIABLE profile{SIDE} ("portraits/orcs/transparent/grunt-$random|.png")}
                    {CLEAR_VARIABLE random}
                [/then]
            [/if]
        [/then]
        [else]
            {VARIABLE profile{SIDE} $leader{SIDE}.profile}
        [/else]
    [/if]
#enddef
